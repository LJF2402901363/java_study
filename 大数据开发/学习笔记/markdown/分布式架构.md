# 分布式架构学习

## 1.分布式架构

### 1.1分布式架构特点

#### 1.1.1分布性

分布式系统中的多台计算机都会在空间上随意分布，同时，机器上的分布也会随时变动。

#### 1.1.2对等性

分布式系统中的计算机没有主从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。

> **副本**：是分布式系统中最常见的一个概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。
>
> **数据副本**：在不同的节点上持久化同一份数据，当某个一节点上存储的数据丢失时，可以从副本上读取到该数据，这是解决分布式系统数据丢失的问题的最有效手段。
>
> **服务副本**：指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行 相应处理。

#### 1.1.3并发性

一个分布式系统中的多个节点，可能会冰法地操作一些共享的资源，诸如数据库或分布式存储等。

#### 1.1.4缺乏全局时钟

一个典型的分布式系统是由一系列在空间上随意分布的多个进程组成的，具有明显的分布性，这些进程通过交换消息来进行相互通信。因此在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。

#### 1.1.5故障总会发生

组成分布式系统的所有计算机，都有可能发生任何形式的故障。一个被大量工程实践所检验的黄金定理是：任何在设计阶段考虑到的异常情况，一定在系统实际运行中发生，并且，在系统实际运行过程中还会遇到很多设计时未能考虑到的异常情况。所以，除非需求指标允许，在系统设计时不能放过任何异常 情况。

### 1.2分布式的环境

#### 1.2.1通信异常

​	分布式系统需要在各个节点之间进行网络通讯，因此每个网络通信都回班随着网络不可用的风险，网络光纤，路由器或是dns等硬件设施或是系统不可用都可能会导致分布式系统无法顺利完成一次网络通讯。

​	另外，即使分布式系统各节点之间的网络通信能够正常进行，其延时也要远大于单机操作。而巨大的时延差别，也会影响消息的收发过程，因此消息丢失和消息时延是非常普遍的。

#### 1.2.2网络分区

​	当网络由于发生异常情况，导致分布式系统中部分节点之间的网络时延不断增大，最终导致分布式系统中的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能正常通信，该现象就被称之为——网络分区。这就对分布式一致性提出了非常大的挑战。

#### 1.2.3三态

​	在分布式环境之下，网络可能 出现各种各样的问题，因此分布式系统的每一次请求与响应，存在“**三态”**概念，即成功，失败与超时。

​	当分布式系统的网络出现异常时，可能出现超时现象，通常有两种情况：

①发送方在发送消息过程中丢失了消息。

②接收方成功接收到消息后，发送响应消息，但该响应消息在发送过程中丢失了。

​	当出现了这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理。

#### 1.2.4节点故障

​	组成的分布式系统的服务器节点出现宕机或者“僵死”现象就被称之为“节点故障”。通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生。

### 1.3事务的ACID

事务(Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元(Unit)，狭义上的事务特指数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持数据一致性的方法。

#### 1.3.1原子性

​	事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许要么全部成功执行；要么全部不执行。
​	任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。

#### 1.3.2一致性

​	事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此当数据库只包含成功事务提交的结果时，就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。

#### 1.3.3隔离性

​	事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

#### 1.3.4持久性

事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来——即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。

### 1.4分布式事务CAP定理

#### 1.4.1CAP定理

CAP理论告诉我们，一个分布式系统不可能同时满足一致性(C:Consistency)、可用性.(A:Availability)和分区容错性(P:Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。

![image-20211220210039447](https://gitee.com/ljf2402901363/picgo-images/raw/master/typora/20211220210158.png)

##### 一致性（C）

在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。

##### 可用性（A）

可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

##### 分区容错性（P）

分区容错性约束了一个分布式系统需要具有如下特性:分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

> 网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等)中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。
> 需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。



#### 1.4.2CAP定理的应用

![image-20211220210354698](https://gitee.com/ljf2402901363/picgo-images/raw/master/typora/20211220210354.png)

从 CAP定理中我们可以看出，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个需求。另一方面，需要明确的一点是，对于一个分布式系统而言，分区容错性可以说是一个最基本的要求。为什么这样说，其实很简单，因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。
从CAP定理中我们可以看出，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个需求.另一方面，需要明确的一点是，对于一个分布式系统而言，分区容错性可以说是一个最基本的要求.为什么这样说，其实很简单，因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络.而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题.因此系统架构设计师往往需要把精力花在如何根据业务特点在C(一致性)和A(可用性)之间寻求平衡.)



### 1.5分布式BASE理论

​	BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。

#### 1.5.1基本可用（basically  available）

​	基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—─但请注意，这绝不等价于系统不可用。以下两个就是“基本可用”的典型例子。
①响应时间上的损失:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障)，查询结果的响应时间增加到了1~2秒。
②功能上的损失:正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。



#### 1.5.2软状态（soft state）

弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

#### 1.5.3最终一致性（eventually consistent）

​	最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

​	在实际工程实践中，最终一致性存在以下五类主要变种。

##### 因果一致性(Causal consistency )


​	因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值,并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。·

##### 读己之所写(Read your writes )

​	读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值,而不会看到旧值。也就是说,对于单个数据获取者来说,其读取到的数据，一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果-致性。



##### 会话一致性(Session consistency)

​	会话一致性将对系统数据的访问过程框定在了一个会话当中:系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更能操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。

##### 单调读一致性( Monotonic read consistency )

​	单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后,那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。

##### 单调写一致性(Monotonic write consistency)

单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。

## 2.一致性协议

### 2.1   **2PC**

​	2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。

​	通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。

![image-20211220214606930](https://gitee.com/ljf2402901363/picgo-images/raw/master/typora/20211220214607.png)

#### 2.1.1阶段一：提交事务请求

> 1．事务询问。
> 协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，
> 等待各参与者的响应。
> 2．执行事务。
> 各参与者节点执行事务操作，并将Undo和 Redo信息记入事务日志中。
> 3．各参与者向协调者反馈事务询问的响应。
> 如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事
> 执行;如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。

#### 2.1.2执行事务提交：执行事务提交

在阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。

##### 执行事务提交

假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交。

> 1．发送提交请求。·························
> 协调者向所有参与者节点发出Commit请求。
> 2．事务提交。
> 参与者接收到Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。
> 3．反馈事务提交结果。
> 参与者在完成事务提交之后，向协调者发送Ack 消息。
>
> 4．完成事务。
> 协调者接收到所有参与者反馈的Ack 消息后，完成事务。



##### 中断事务

假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。

> 1．发送回滚请求。
> 协调者向所有参与者节点发出Rollback请求。
> 2．事务回滚。
> 参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。3．反馈事务回滚结果。
> 参与者在完成事务回滚之后，向协调者发送Ack 消息。
> 4．中断事务。
> 协调者接收到所有参与者反馈的Ack 消息后，完成事务中断。



### 2.2 **3PC**